[Back](../readme.md)
# 10-09-25

## Device Interrupts
- OS kernel needs to communicate with physical devices
- Device operates asynchronously from the CPU
    - Kernel waits until I/O is done
    - Interrupts: Kernel can do other work in the meantime
- Device access to memory
- When using devices, an interrupt appears, initiating a mode switch
    - The kernel saves the context of the current process and loads the context of the interrupt handler
    - After the interrupt is handled, the kernel restores the original process context
- Interrupts can be disabled and enabled
    - Interrupt handlers must be written carefully to avoid race conditions

## How does device interrupts work?
- stack of instructions with different addresses that are pointed to.
- When an interrupt occurs, the CPU stops executing the current process and saves its context (registers, program counter, etc.) onto the stack.
- The CPU then loads the context of the interrupt handler and starts executing it.
- After the interrupt handler is done, the CPU restores the original process context from the stack and resumes its execution.

## How do we take interrupts safely?
- Interrupt vector (entry points are limited).
    - Table of pointers to interrupt handlers to run different events.
- Atomic transfer control.
- Transparent restartable execution.

## Interrupt stack
- Per-processor, located in kernel space.
- Used to save the context of the interrupted process and the state of the CPU registers.

## Interrupt masking (we dont want to loose interrupts)
- Interrupt handler runs with interrupts off
- OS kernel can also turn interrupts off
- ON x86
    - CLI: disabled interrupts
    - STI: enabled interrupts
    - only applies to the current CPU on a multicore
- We'll need to implement synchronization in chapter 5
- Only interruptions on one core, no cross-core interrupts.

### MIPS
- RISC architecture
- Interrupts are masked on a per-CPU basis.
- Each CPU has its own interrupt mask register.
- MIPS uses a similar CLI/STI mechanism to disable/enable interrupts.

## x86
- CISC architecture
- Interrupts are masked on a per-CPU basis.
- Each CPU has its own interrupt mask register.
- x86 uses a similar CLI/STI mechanism to disable/enable interrupts.

## At end of handler
- Handler restores saved registers
- Automatically return to interrupted process/thread
    - Restore program counter
    - Restore program stack
    - Restore process status word/condition codes
    - Switch to user mode

## Upcall: User level event delivery
- Notify user process of some event that needs to be handled right away.
    - Time expiration
    - Interrupt delivery for VM player
    - Asynchronous I/O completion
- User-level threads can be notified of events via upcalls.

## Uppcalls vs Interrupts
- Signal handlers = interrupt vector
- Signal stack = interrupt stack
- Automatic save/restore registers = transparent resume
- Signal masking: signals disabled while in signal handler

***NOTAT***: Be lærer om å gi en prosess av det han lærer der han viser til pensum.